
from httplib2 import Http
from urllib import urlencode
import json

class EntityFactory():
    
    """ Base class for subclasses that are used to create entity objects from underlying data. """

    @classmethod
    def from_json(cls, json_obj):
        raise Exception(str(cls) + " subclass does not implement EntityFactory.from_json() method.") # must be overridden by the subclass, otherwise throws exception

    @classmethod
    def from_json_list(cls, json_obj):
        """ Deserializes a collection of objects from a JSON representation. """
        entities = list()
        for entity in json_obj:
            entities.append(cls.from_json(entity))
        return entities


class EntityProvider():

    """Base class for all entity provider classes.

    The EntityProvider base class holds a reference to the TrelloClient object that actually 
    calls the relevant API. The Provider subclasses contain the URL formatting / logic required
    to drive the API for the relevant entity.

    """

    def __init__(self, trello_client):
        self.client = trello_client


class ResourceUnavailable(Exception):

    """Exception representing a failed request to a resource."""

    def __init__(self, url, status_code, content):
        Exception.__init__(self)
        self._url = url
        self._status = status_code
        self._msg = content

    def __str__(self):
        print "Resource unavailable at %(url)s\nAPI response = %(status)s %(message)s" % {'status':self._status, 'message':self._msg, 'url':self._url}


class TrelloClient(object):

    """ Base class for Trello API access."""

    def __init__(self, api_key, token, api_secret = None, token_secret = None):
        """
        Constructor

        :api_key: API key generated at https://trello.com/1/appKey/generate
        :oauth_token: OAuth token generated by the user

        """

        if api_key and api_secret and token and token_secret:
            # oauth
            self.oauth_consumer = oauth.Consumer(key = api_key, secret = api_secret)
            self.oauth_token = oauth.Token(key = token, secret = token_secret)
            self.client = oauth.Client(self.oauth_consumer, self.oauth_token)

        elif api_key and token:
            self.client = Http()

        self.api_key = api_key
        self.auth_token = token

    def logout(self):
        """Log out of Trello. This method is idempotent."""

        # TODO: refactor
        pass
        #if not self._cookie:
            #return

        #headers = {'Cookie': self._cookie, 'Accept': 'application/json'}
        #response, content = self.client.request(
                #'https://trello.com/logout',
                #'GET',
                #headers = headers,
                #)

        ## TODO: error checking
        #self._cookie = None

    def build_url(self, path, query = {}):
        """
        Builds a Trello URL.

        :path: URL path
        :params: dict of key-value pairs for the query string

        """
        url = 'https://api.trello.com/1'
        if path[0:1] != '/':
            url += '/'
        url += path

        if hasattr(self, 'oauth_token'):
            url += '?'
            url += "key="+self.oauth_token.key
            url += "&token="+self.oauth_consumer.key
        else:
            url += '?'
            url += "key="+self.api_key
            url += "&token="+self.auth_token

        if len(query) > 0:
            url += '&'+urlencode(query)

        return url

    def fetch_json(
            self,
            uri_path,
            http_method = 'GET',
            headers = {},
            query_params = {},
            post_args = {}):
        """ Fetch some JSON from Trello """

        headers['Accept'] = 'application/json'
        url = self.build_url(uri_path, query_params)
        response, content = self.client.request(
                url,
                http_method,
                headers = headers,
                body = json.dumps(post_args))

        # error checking
        if response.status != 200:
            raise ResourceUnavailable(url, response.status, content)
        return json.loads(content)
